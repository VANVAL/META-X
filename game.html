<html>

<head>
	<title>META-X</title>
	<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
	<script type="text/javascript" src="js/three/three.js"></script>
	<script type="text/javascript" src="js/three/MTLLoader.js"></script>
	<script type="text/javascript" src="js/three/OBJLoader.js"></script>
	<link rel="stylesheet" type="text/css" media="screen" href="css/main.css" />
	<link rel="stylesheet" type="text/css" media="screen" href="css/game.css" />
	<script type="text/javascript">
		var scene;
		var scene2;
		var camera;
		var camera2;
		var renderer;
		var renderer2;
		var controls;
		var objects = [];
		var clock;
		var clock2;
		var deltaTime;
		var keys = {};

		//TODO:VARIABLE DE PRUEBA
		var naveTest;
		var naveTest2;
		//TODO: END




		//TODO: MODELOS AQUI
		var spaceship1;
		var spaceship2;
		var spaceship3;
		var asteroid;
		var fondo;
		//TODO: TERMINAN MODELOS


		//TODO: VARIABLES HUD 
		var cameraOrtho, sceneOrtho;
		var spriteTL, spriteTR, spriteBL, spriteBR, spriteC;
		var mapC;
		var group;
		//TODO: END HUD



		//objeto para la colision
		var raycaster;
		var objetosConColision = []; //los objetos que si tenga colision  los agregamos a este arreglo
		//UNA VEZ QUE QUITES EL OBJETO DE LA ESCENA QUITALO DEL ARREGLO TAMBIEN

		/* var raycaster2;
		var objetosConColision2 = []; */


		var isWorldReady = [false, false];
		$(document).ready(function () {


			//inicializando el raycaster
			raycaster = new THREE.Raycaster();
			//raycaster2 = new THREE.Raycaster();

			setupScene();
			//setupScene2();


			//creando los rayos a disparar para la colision
			camera.rayos = [
				new THREE.Vector3(1, 0, 0),
				new THREE.Vector3(-1, 0, 0),
				new THREE.Vector3(0, 0, 1),
				new THREE.Vector3(0, 0, -1),
			]; //esta disparando en sus 4 puntos cardinales


			//TODO: MODELS
			loadOBJWithMTL("assets/ship1/", "spaceship1Triangles.obj", "spaceship1Triangles.mtl", (spaceship1) => {

				naveTest = spaceship1;

				spaceship1.position.x = -100;
				spaceship1.position.z = -30;
				spaceship1.scale.set(2, 3, 3);

				var spaceship2 = spaceship1.clone();
				naveTest2 = spaceship2;

				spaceship1.rotation.y = THREE.Math.degToRad(90);
				spaceship1.rotation.x = THREE.Math.degToRad(270);

				spaceship2.rotation.y = THREE.Math.degToRad(90);
				spaceship2.rotation.x = THREE.Math.degToRad(270);
				spaceship2.position.x = -100;
				spaceship2.position.z = 30;


				scene.add(spaceship1);
				scene.add(spaceship2);


				//objetosConColision.push(spaceship1);
				isWorldReady[0] = true;
			});


			loadOBJWithMTL("assets/asteroid/", "AsteroidTriangles.obj", "AsteroidTriangles.mtl", (asteroid) => {

				asteroid.position.x = 10;
				//scene.add(asteroid);


				//objetosConColision.push(asteroid);
				isWorldReady[1] = true;
			});

			loadOBJWithMTL("assets/", "cube3.obj", "cube3.mtl", (fondo) => {

				fondo.position.y = -150;
				fondo.rotation.x = THREE.Math.degToRad(90);
				//fondo.rotation.y= THREE.Math.degToRad(180);
				fondo.scale.set(18, 18, 1);
				scene.add(fondo);

				//objetosConColision.push(fondo);

				//isWorldReady[5] = true;
			});

			/* loadOBJWithMTL("assets/ship3/", "ship3.obj", "ship3.mtl", (spaceship3) =>{
				
				spaceship3.position.x=20;
				spaceship3.position.z=20;				
				scene.add(spaceship3);
				

				objetosConColision.push(spaceship3);
				isWorldReady[4] = true;
			}); */
			//TODO: MODELS END



			render();

			document.addEventListener('keydown', onKeyDown);
			document.addEventListener('keyup', onKeyUp);


			// TODO: BOTON SALIR 
			$("body").on('click', '#btnExit', function () {
				$(location).attr('href', 'mainMenu.html');
			});
			//TODO: TERMINA BOTON SALIR

		});

		function loadOBJWithMTL(path, objFile, mtlFile, onLoadCallback) {
			var mtlLoader = new THREE.MTLLoader();
			mtlLoader.setPath(path);
			mtlLoader.load(mtlFile, (materials) => {

				var objLoader = new THREE.OBJLoader();
				objLoader.setMaterials(materials);
				objLoader.setPath(path);
				objLoader.load(objFile, (object) => {
					onLoadCallback(object);
				});
			});
		}

		function onKeyDown(event) {
			keys[String.fromCharCode(event.keyCode)] = true;
		}

		function onKeyUp(event) {
			keys[String.fromCharCode(event.keyCode)] = false;
		}


		function render() {
			requestAnimationFrame(render);
			deltaTime = clock.getDelta();

			var yaw = 0;
			var forward = 0;
			var yaw2 = 0;
			var forward2 = 0;
			//PLAYER 1
			if (keys["A"]) {
				yaw = -40;


			} else if (keys["D"]) {
				yaw = 40;
			}
			if (keys["W"]) {
				forward = 40;
				//naveTest.rotation.y += THREE.Math.degToRad(15);
			} else if (keys["S"]) {
				forward = -40;
			}

			//PLAYER 2 
			if (keys["J"]) {
				yaw2 = -40;

			} else if (keys["L"]) {
				yaw2 = 30;
			}
			if (keys["I"]) {
				forward2 = 40;
			} else if (keys["K"]) {
				forward2 = -40;
			}

			if (isWorldReady[0] && isWorldReady[1]) {


				//TODO: Colisiones spaceship1
				/* for(var i = 0; i < spaceship1.rayos.length; i++)
				{
					var rayo2= spaceship1.rayos[i];
					raycaster2.set(spaceship1.position, rayo2);

					var colision2 = raycaster2.intersectObjects(objetosConColision, true); 

					if (colision2.length > 0 && colision2[0].distance < 1) {
						//debugger;
						console.log("COLISIONANDO!!");

						//SOLUTION
						scene.remove(colision2[0].object.parent);

					}
				} */
				//TODO: Terminan colisiones spaceship1


				//EVALUANDO LA COLISION
				//le preguntamos a THREEJS vector por vector, cuales han chocado (lo recorremos con un for)

				for (var i = 0; i < camera.rayos.length; i++) {

					var rayo = camera.rayos[i];


					raycaster.set(camera.position, rayo); //primer parametro desde donde y el ultimo hacia donde va TODO EN VECTORES

					//DETECTANDO LA COLISION

					//var colision = raycaster.intersectObject(box);//checa colision con un solo objecto, tenemos que duplicarlo para todos los demas objetos :C
					//Existe una variante con objects envez de object y con eso le pasamos el arreglo de objetos con los que queremos que colisione

					//esto es un arreglo tmb
					var colision = raycaster.intersectObjects(objetosConColision, true); //este es el metodo chido uwu
					//el true tambien verigfica colision con los hijos de los modelos, en caso de que no pase por el padre uwu


					//validando que el arreglo tiene un dato(oseae  qeu colisionÃ³)
					if (colision.length > 0 && colision[0].distance < 1) {
						//debugger;
						console.log("COLISIONANDO!!");

						//SOLUTION
						scene.remove(colision[0].object.parent);



						//MY TRIES
						/*for(var i=0; i<colision.length; i++)
						{
							scene.remove( collisions[0].object );
						}*/

						//scene.remove(this.colision[i].object());

					}

					//NOS DAMOS CUENTA QUE YA MARCA COLISIONES SIN ESTAR CERCA DEL OBJETO PARA ESO LE CAMBIAMOS LA DISTANCIA DEL RAYO

				}
				//naveTest.rotation.y += yaw * deltaTime;
				naveTest.translateY(forward * deltaTime);
				naveTest.translateZ(yaw * deltaTime);

				naveTest2.translateY(forward2 * deltaTime);
				naveTest2.translateZ(yaw2 * deltaTime);

			}

			//TODO: HUD 
/*
			var time = Date.now() / 1000;

			for (var i = 0, l = group.children.length; i < l; i++) 
			{
				var sprite = group.children[i];
				var material = sprite.material;
				var scale = Math.sin(time + sprite.position.x * 0.01) * 0.3 + 1.0;
				var imageWidth = 1;
				var imageHeight = 1;


				if (material.map && material.map.image && material.map.image.width) {
					imageWidth = material.map.image.width;
					imageHeight = material.map.image.height;
				}
				sprite.material.rotation += 0.1 * (i / l);
				sprite.scale.set(scale * imageWidth, scale * imageHeight, 1.0);
				if (material.map !== mapC) {
					material.opacity = Math.sin(time + sprite.position.x * 0.01) * 0.4 + 0.6;
				}
			}

			group.rotation.x = time * 0.5;
			group.rotation.y = time * 0.75;
			group.rotation.z = time * 1.0;
			renderer2.clear();
			renderer2.render(scene, camera);
			renderer2.clearDepth();
			renderer2.render(sceneOrtho, cameraOrtho);
*/
			//TODO: TERMINA HUD
			renderer.render(scene, camera);

		}

		function setupScene() {
			var visibleSize = {
				width: window.innerWidth,
				height: window.innerHeight
			};
			clock = new THREE.Clock();
			scene = new THREE.Scene();
			camera = new THREE.PerspectiveCamera(90, visibleSize.width / visibleSize.height, 0.1, 300);
			camera.position.z = 0;
			camera.position.y = 80;
			camera.rotation.x = THREE.Math.degToRad(-90);

			renderer = new THREE.WebGLRenderer({
				precision: "mediump"
			});
			renderer.setClearColor(new THREE.Color(0, 0, 0));
			renderer.setPixelRatio(visibleSize.width / visibleSize.height);
			renderer.setSize(visibleSize.width / 1.22, visibleSize.height);
			//renderer.setSize(visibleSize.width/1.22, visibleSize.height/2);

			var ambientLight = new THREE.AmbientLight(new THREE.Color(1, 1, 1), 1.0);
			scene.add(ambientLight);

			var directionalLight = new THREE.DirectionalLight(new THREE.Color(1, 1, 0), 0.4);
			directionalLight.position.set(0, 0, 1);
			scene.add(directionalLight);

			//var grid = new THREE.GridHelper(50, 10, 0xffffff, 0xffffff);
			//grid.position.y = -1;
			//scene.add(grid);

			$("#scene-section").append(renderer.domElement);

			//TODO: HUD
/*
			cameraOrtho = new THREE.OrthographicCamera(
				-window.innerWidth / 2,
				window.innerWidth / 2,
				window.innerHeight / 2,
				-window.innerHeight / 2,
				1,
				10
			);
			cameraOrtho.position.z = 10;

			scene = new THREE.Scene();
			scene.fog = new THREE.Fog(0x000000, 1500, 2100);

			sceneOrtho = new THREE.Scene();
			var textureLoader = new THREE.TextureLoader();

			var amount = 200;
			var radius = 500;


			textureLoader.load("img/angry.png", createHUDSprites);

			var mapB = textureLoader.load("img/angry.png");
			mapC = textureLoader.load("img/angry.png");
			group = new THREE.Group();

			var materialC = new THREE.SpriteMaterial({
				map: mapC,
				color: 0xffffff,
				fog: true
			});
			var materialB = new THREE.SpriteMaterial({
				map: mapB,
				color: 0xffffff,
				fog: true
			});

			for (var a = 0; a < amount; a++) {

				var x = Math.random() - 0.5;
				var y = Math.random() - 0.5;
				var z = Math.random() - 0.5;

				var material;

				if (z < 0) {
					material = materialB.clone();
				} else {
					material = materialC.clone();
					material.color.setHSL(0.5 * Math.random(), 0.75, 0.5);
					material.map.offset.set(-0.5, -0.5);
					material.map.repeat.set(2, 2);
				}

				var sprite = new THREE.Sprite(material);

				sprite.position.set(x, y, z);
				sprite.position.normalize();
				sprite.position.multiplyScalar(radius);
				group.add(sprite);
			}
			scene.add(group);

			renderer2 = new THREE.WebGLRenderer();
			renderer2.setPixelRatio(window.devicePixelRatio);
			renderer2.setSize(window.innerWidth, window.innerHeight);
			renderer2.autoClear = false; // To allow render overlay on top of sprited sphere
			document.body.appendChild(renderer2.domElement);
			
			window.addEventListener('resize', onWindowResize, false);
*/
			//TODO: END HUD

		}


		//TODO: FUNCIONES HUD
		/*function createHUDSprites(texture) {
			var material = new THREE.SpriteMaterial({
				map: texture
			});

			var width = material.map.image.width;
			var height = material.map.image.height;

			spriteTL = new THREE.Sprite(material);
			//spriteTL.center.set(0.0, 1.0);
			spriteTL.position.set(0.0,1.0,0.0);
			spriteTL.scale.set(width, height, 1);

			sceneOrtho.add(spriteTL);

			spriteTR = new THREE.Sprite(material);
			//spriteTR.center.set(1.0, 1.0);
			spriteTR.position.set(1.0,0.0,1.0);
			spriteTR.scale.set(width, height, 1);

			sceneOrtho.add(spriteTR);
			
			
			spriteBL = new THREE.Sprite(material);
			debugger
			//spriteBL.center.set(0.0, 0.0);
			spriteBL.position.set(0.0,0.0,0.0);
			spriteBL.scale.set(width, height, 1);

			sceneOrtho.add(spriteBL);

			spriteBR = new THREE.Sprite(material);
			//spriteBR.center.set(1.0, 0.0);
			spriteBR.position.set(1.0,0.0,0.0);
			spriteBR.scale.set(width, height, 1);

			sceneOrtho.add(spriteBR);

			spriteC = new THREE.Sprite(material);
			//spriteC.center.set(0.5, 0.5);
			spriteC.position.set(0.5,0.5,0.0);
			spriteC.scale.set(width, height, 1);

			sceneOrtho.add(spriteC);

			updateHUDSprites();
		}

		function updateHUDSprites() {
			var width = window.innerWidth / 2;
			var height = window.innerHeight / 2;

			spriteTL.position.set(-width, height, 1); // top left

			spriteTR.position.set(width, height, 1); // top right

			spriteBL.position.set(-width, -height, 1); // bottom left

			spriteBR.position.set(width, -height, 1); // bottom right

			spriteC.position.set(0, 0, 1); // center
		}

		function onWindowResize() {
			var width = window.innerWidth;
			var height = window.innerHeight;

			camera.aspect = width / height;
			camera.updateProjectionMatrix();

			cameraOrtho.left = -width / 2;
			cameraOrtho.right = width / 2;
			cameraOrtho.top = height / 2;
			cameraOrtho.bottom = -height / 2;

			cameraOrtho.updateProjectionMatrix();

			updateHUDSprites();

			renderer2.setSize(window.innerWidth, window.innerHeight);
		}

		function animate() {
			requestAnimationFrame(animate);
			render();
		}*/
		//TODO: TERMINAN FUNCIONES HUD
	</script>
</head>

<body>
	<!--<audio src="audio/Maintitle.mp3" loop autoplay></audio>-->
	<div id="leftContainerG">
		<div id="canvasP1">
			<div id="scene-section"></div>
		</div>
		<!--<div id="canvasP2">
					<div id="scene-section2"></div>
				</div>-->
	</div>

	<div id="rightContainerG">
		<div id="controlsContainer">
			<div class="playerControls">
				<p>PLAYER 1</p>
				<img src="img/wasd.png" alt="controls">

			</div>
			<div class="playerControls">
				<p>PLAYER 2</p>
				<img src="img/arrowKeys.png" alt="controls">
			</div>
			<div class="playerControls">
				<p>PAUSE</p>
				<img src="img/letter_p.png" alt="">
			</div>

			<button id="btnExit" class="button" style="width: 100px; top: 20px;">EXIT</button>

		</div>
	</div>
</body>

</html>